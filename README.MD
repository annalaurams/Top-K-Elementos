# **Top K Elementos**

Atividade para a disciplina de Algoritmos e Estruturas de Dados II. <br/>

## Sum√°rio üìï 

- [Objetivos](#Objetivos)
- [Estrutura](#Estrutura)
- [Diretrizes](#Diretrizes)
- [Decis√µes de Implementa√ß√£o](#Decis√µes_de_Implementa√ß√£o)
- [Fun√ß√µes](#Fun√ß√µes)
- [Resultados](#Resultados)
- [Tempo de execu√ß√£o e Custo computacional](#Tempo_de_execu√ß√£o_e_Custo_computacional)
- [Conclus√£o](#Conclus√£o)
- [Compila√ß√£o e execu√ß√£o](#Compila√ß√£o-e-execu√ß√£o)
- [Refer√™ncias](#Refer√™ncias)

## Objetivo

O objetivo √© desenvolver um algoritmo utilizando-se tabela hash e o m√©todo heap sort para resolver um problema cl√°ssico chamado "Top K itens". 
Neste tipo de problema √© preciso encontrar os K itens mais valiosos de uma cole√ß√£o de dados. Logo, utiliza-se o hash para contar a frequ√™ncia de todos os itens, enquanto o heap se aplica na manuten√ß√£o de uma lista dos K itens de maior valor. 

## Estrutura

- ```topk.hpp:``` Engloba a struct WordInfo, todas as fun√ß√µes utilizadas e seus par√¢metros.
- ```topk.cpp:``` Cont√©m a cria√ß√£o e o desenvolvimento de todas as fun√ß√µes do c√≥digo.    
- ```main.cpp:``` Pertence a parte de leitura dos arquivos, chamada das fun√ß√µes usadas e o tempo de execu√ß√£o do programa.
- ```include.hpp:``` Inclui biliotecas e arquivos a serem utilizados.
- ```text1.txt:``` Texto de entrada. 
- ```text2.txt:``` Texto de entrada. 
- ```stopwords.txt:``` Artigos e conjun√ß√µes como (a, o, as, os, e, ou).

## Diretrizes ‚òëÔ∏è 

As especifica√ß√µes a seguir foram propostas para discuss√£o e resolu√ß√£o do problema:

- A partir de um texto de entrada, o algoritmo realiza a leitura dele e cria uma tabela de dispers√£o (hash) intitulada ```glossary```, para contar quantas vezes cada palavra aparece no texto. A chave do hash √© a pr√≥pria palavra.
- O conte√∫do do arquivo de stopWords, que podem ser alteradas de acordo com a prefer√™ncia do usu√°rio, √© salvo em outra tabela de dispers√£o. As stopWords que forem econtradas no texto, s√£o em seguida exclu√≠das. Pois, por serem artigos e conjun√ß√µes facilmente seriam as mais frequentes do heap, no entanto foram desconsideradas.
- Em seguida, a partir de um valor K, √© inserido em um vetor ```heap``` as primeiras K palavras guardadas no hash e depois s√£o ordenados de forma que a menor ocorr√™ncia das K palavras inseridas esteja na primeira posi√ß√£o do vetor.
- Ap√≥s isso para cada elemento restante na hash, √© realizado compara√ß√µes com o menor valor contido no heap:

  1. Se a ocorr√™ncia for maior do que o menor valor da heap, o menor vaor √© removido, o novo elemento √© inserido e a estrutura novamente organizada
  2. Caso contr√°rio, o elemento deve ser ignorado, e √© comparado o pr√≥ximo dado at√© o fim do gloss√°rio.
- No final, a heap conter√° os K elementos com maiores valores (ocorr√™ncias) dentre os textos lidos. 

<div style="display: flex; justify-content: center;">
    <img src="img/exemploHeap.gif" width="300" height="300">
</div>

-  Este programa dever√° ler uma cole√ß√£o de arquivos contento textos sem nenhuma formata√ß√£o ("arquivo ASCII") onde cada senten√ßa termina por um sinal de pontua√ß√£o (".", "?", "!"").
- Cada par√°grafo √© separado por, pelo menos, uma linha em branco.
- Considere como palavra uma sequ√™ncia de letras delimitada por espa√ßo em branco, ‚Äùcoluna da esquerda‚Äù, ‚Äùcoluna da direita‚Äù e s√≠mbolos de pontua√ß√£o.

- Os arquivos de entrada s√£o lidos caracter por caracter.

- O programa permite a leitura de v√°rios arquivos de texto ao mesmo tempo, no entanto existem algumas regras:
  1. Para cada novo arquivo que se deseja ler, deve ser colocado dentro da pasta ```data```. 
  2. O nome dos arquivos de texto seguem um padr√£o de "text1.txt" (1¬∞ arquivo), "text2.txt"(2¬∞ arquivo) e assim sucessivamente, logo devem ser renomeados. 
  3. Al√©m disso, a vari√°vel ```FILES``` dentro do ```include.hpp``` guarda a quantidade de arquivos a serem lidos, portanto, modifique para a quantidade desejada.

- Dentro do arquivo ```include.hpp```possui a vari√°vel K que corresponde ao tamanho do heap, tamb√©m pode ser alterada.

## Decis√µes de implementa√ß√£o üìù

```unordered_map:``` Implementado usando a tabela de hash, o qual tem uma fun√ß√£o de hash para calcular o √≠ndice de armazenamento de cada elemento, permitindo um acesso direto aos dados, sem a necessidade de percorrer todos. √â poss√≠vel localizar, inserir e remover elementos com uma chave especificada, que neste caso √© a palavra. Essa estrutura tamb√©m armazena um valor, que neste caso se refere a struct ```WordInfo```que armazena as ocorr√™ncias. Al√©m disso, o unordered_map n√£o mant√©m os elementos ordenados.

  - Alguns benef√≠cios de usar essas estruturas s√£o: rapidez em acessas elementos e a capacidade de armazenar enormes entradas de dados.

```Heap:``` O algoritmo implementa heapify para uma min-heap. Uma min-heap √© uma estrutura de dados em que cada n√≥ tem um valor menor ou igual ao valor de seus filhos. O algoritmo de heapify √© usado para manter uma min-heap em ordem.

<div style="text-align:center">
    <img src="img/minHeap.png" height="300" width="350">
</div>


O algoritmo de heapify √© um algoritmo que garante que a √°rvore permane√ßa um heap, mesmo quando os elementos s√£o inseridos ou removidos. O algoritmo funciona da seguinte forma:

  1. Comece no n√≥ da raiz da √°rvore e verifique se o n√≥ tem filhos.
  2. Se o n√≥ tiver filhos, verifique se o valor do n√≥ √© maior ou igual ao valor dos seus filhos.
  3. Se o valor do n√≥ n√£o for maior ou igual ao valor dos seus filhos, troque o valor do n√≥ com o valor do maior filho.
  4. Repita os passos 2 a 4 para o filho do n√≥ que foi trocado.
O algoritmo de heapify garante que as maiores ocorr√™ncias sejam organizadas como um heap.

  - Alguns benef√≠cios de usar essas estruturas s√£o: Efici√™ncia para pesquisa, inser√ß√£o e remo√ß√£o.


 ## Fun√ß√µes 

- ```addStopWord``` : Adiciona as stop words no gloss√°rio destinado para elas.
- ```existentWord```: Verifica as stop words presentes no gloss√°rio e remove elas dele.
- ```manyFiles```: Guarda o nome dos arquivos dos textos de entrada em um vector.
- ```printGlossary``` : Imprimi o gloss√°rio de palavras de ambos os textos juntos.
- ```fileReading``` : Realiza leitura caracter por caracter dos textos de entrada, utilizando um switch case, essa fun√ß√£o processa, identifica as palavras e adiciona cada uma no gloss√°rio.
- ```cases``` : Realiza a contagem de ocorr√™ncia de cada palavra a medida que o texto √© lido.
- ```Accentuation``` : Procedimento que trata palavras acentuadas para aparecerem corretamente.
- ```removeErro``` : Exclui poss√≠veis strings vazias do gloss√°rio.
- ```insertK``` : Insere os primeiros K elementos do hash no heap.
- ```printHeap``` : Imprimi o heap de forma crescente.
- ```finaleHash``` : Realiza inser√ß√£o do restante dos itens do hash, a partir da posi√ß√£o K, insere ou troca as maiores ocorr√™ncias do hash com o menor do heap.
- ```heapify``` : Respons√°vel por garantir que o valor no n√≥ seja maior ou igual aos valores de seus filhos. 
- ```heapSort``` : Ordena o heap de maneira crescente.

 ## Tempo de execu√ß√£o e Custo Computacional üïú

A contagem foi feita pelas ferramentas disponibilizadas pela bibioteca "time.h". <br/>
A m√©dia geral do tempo de execu√ß√£o deste c√≥digo √©: 491,123 ms

Unordered_map: Melhor caso: O(1)
               Pior caso O(n)

Heap: O(nlogk), onde n √© o tamanho da cole√ß√£o de dados e k o n√∫mero de itens mais relevantes.

## Resultados ‚úÖ

Ao final da execu√ß√£o √© mostrado o heap com as palavras que cont√©m maiores ocorr√™ncias da cole√ß√£o de dados.
A ordem das ocorr√™ncias seguem a estrutura de um heap.

<div style="text-align:center">
    <img src="img/output.png" height="400" width="400">
</div>


## Conclus√£o üìã

Ao realizar o projeto "Top K itens", foi poss√≠vel explorar t√©cnicas de programa√ß√£o utilizando estruturas como o tabela hash e o m√©todo heap.
Esse algoritmo √© uma combina√ß√£o eficiente do uso de hash para contar a frequ√™ncia dos elementos e heap para manter a lista dos K elementos com maiores valores.
Ao combinar as capacidades de contagem r√°pida de hash e a capacidade de manuten√ß√£o de ordem e sele√ß√£o eficiente de heap, o algoritmo consegue atingir um desempenho not√°vel em termos de complexidade temporal para uma grande entrada de dados.


## Compila√ß√£o e Execu√ß√£o üíª 

Esse pequeno exemplo possui um arquivo Makefile que realiza todo o procedimento de compila√ß√£o e execu√ß√£o. <br/>Para tanto, temos as seguintes diretrizes de execu√ß√£o:


| Comando                |  Fun√ß√£o                                                                                           |                     
| -----------------------| ------------------------------------------------------------------------------------------------- |
|  `make clean`          | Apaga a √∫ltima compila√ß√£o realizada contida na pasta build                                        |
|  `make`                | Executa a compila√ß√£o do programa utilizando o gcc, e o resultado vai para a pasta build           |
|  `make run`            | Executa o programa da pasta build ap√≥s a realiza√ß√£o da compila√ß√£o                                 |

## Refer√™ncias üìû

https://learn.microsoft.com/pt-br/cpp/standard-library/unordered-map-class?view=msvc-170
https://www.geeksforgeeks.org/map-vs-unordered_map-c/
https://www.geeksforgeeks.org/heap-data-structure/

### Contato

<div>
 <br><p align="justify"> Anna Laura Moura Santana</p>
 <a href="https://t.me/annalaurams">
 <img align="center" src="https://img.shields.io/badge/Telegram-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white"/> 
 </div>
<a style="color:black" href="mailto:nalauramoura@gmail.com?subject=[GitHub]%20Source%20Dynamic%20Lists">
‚úâÔ∏è <i>nalauramoura@gmail.com</i>
</a>