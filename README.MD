# **Top K Elementos**

Atividade para a disciplina de Algoritmos e Estruturas de Dados II. <br/>

## Sum√°rio üìï 

- [Objetivos](#Objetivos)
- [Estrutura](#Estrutura)
- [Diretrizes](#Diretrizes)
- [Decis√µes de Implementa√ß√£o](#Decis√µes_de_Implementa√ß√£o)
- [Fun√ß√µes](#Fun√ß√µes)
- [Resultados](#Resultados)
- [Tempo de execu√ß√£o e Custo computacional](#Tempo_de_execu√ß√£o_e_Custo_computacional)
- [Conclus√£o](#Conclus√£o)
- [Compila√ß√£o e execu√ß√£o](#Compila√ß√£o-e-execu√ß√£o)
- [Refer√™ncias](#Refer√™ncias)

## Objetivo üéØ 

O objetivo √© desenvolver um algoritmo utilizando-se tabela hash e o m√©todo heap para resolver um problema cl√°ssico chamado "Top K itens". 
Neste tipo de problema √© preciso encontrar os K itens mais valiosos de uma cole√ß√£o de dados. Logo, utiliza-se o hash para contar a frequ√™ncia de todos os itens, enquanto o heap se aplica na manuten√ß√£o de uma lista dos K itens de maior valor. 

## Estrutura üóÇÔ∏è

- ```topk.hpp:``` Engloba a struct WordInfo, todas as fun√ß√µes utilizadas e seus par√¢metros.
- ```topk.cpp:``` Cont√©m a cria√ß√£o e o desenvolvimento de todas as fun√ß√µes do c√≥digo.    
- ```main.cpp:``` Pertence a parte de leitura dos arquivos, chamada das fun√ß√µes usadas e o tempo de execu√ß√£o do programa.
- ```include.hpp:``` Inclui biliotecas e arquivos a serem utilizados.
- ```text1.txt:``` Texto de entrada. 
- ```text2.txt:``` Texto de entrada. 
- ```stopwords.txt:``` Artigos e conjun√ß√µes como (a, o, as, os, e, ou).

## Diretrizes ‚òëÔ∏è 

As especifica√ß√µes a seguir foram propostas para discuss√£o do problema:

- A partir de um texto de entrada, o algoritmo realiza a leitura dele e cria uma tabela de dispers√£o (hash) intitulada ```glossary```, para contar quantas vezes cada palavra aparece no texto. A chave do hash √© a pr√≥pria palavra.
- O conte√∫do do arquivo de stopWords, que podem ser alteradas de acordo com a prefer√™ncia do usu√°rio, √© salvo em outra tabela de dispers√£o. As stopWords que forem econtradas no texto, s√£o em seguida exclu√≠das dele. Pois, por serem artigos e conjun√ß√µes facilmente seriam as mais frequentes do heap, no entanto foram desconsideradas.
- Em seguida, a partir de um valor K, √© inserido em um vetor intitulado ```heap``` as primeiras K palavras guardadas no hash e depois s√£o organizadas de forma que a menor ocorr√™ncia das K palavras inseridas, esteja na primeira posi√ß√£o do vetor.
- Ap√≥s isso para cada elemento restante na hash, √© realizado compara√ß√µes com o menor valor contido no heap, que neste caso s√£o as ocorr√™ncias:

  1. Se a ocorr√™ncia for maior do que o menor valor da heap, o menor valor √© removido, o novo elemento √© inserido e a estrutura novamente organizada.
  2. Caso contr√°rio, o elemento deve ser ignorado, e √© comparado o pr√≥ximo dado at√© o fim do gloss√°rio.
- No final, a heap conter√° os K elementos com maiores valores (ocorr√™ncias) dentre os textos lidos. 

<div style="display: flex; justify-content: center;">
    <img src="img/exemploHeap.gif" width="300" height="300">
</div>

- Este programa dever√° ler uma cole√ß√£o de arquivos contento textos sem nenhuma formata√ß√£o ("arquivo ASCII") onde cada senten√ßa termina por um sinal de pontua√ß√£o (".", "?", "!"").
- Cada par√°grafo √© separado por, pelo menos, uma linha em branco.
- Considere como palavra uma sequ√™ncia de letras delimitada por espa√ßo em branco, ‚Äùcoluna da esquerda‚Äù, ‚Äùcoluna da direita‚Äù e s√≠mbolos de pontua√ß√£o.

- Todos os arquivos de entrada s√£o lidos caracter por caracter.

- O programa permite a leitura de v√°rios arquivos de texto ao mesmo tempo, no entanto existem algumas regras:
  1. Para cada novo arquivo que se deseja ler, deve ser colocado dentro da pasta ```data```. 
  2. O nome dos arquivos de texto seguem um padr√£o de "text1.txt" (1¬∞ arquivo), "text2.txt"(2¬∞ arquivo) e assim sucessivamente, logo devem ser renomeados. 
  3. Al√©m disso, a vari√°vel ```FILES``` dentro do ```include.hpp``` guarda a quantidade de arquivos a serem lidos, portanto, modifique para a quantidade desejada.

- Dentro do arquivo ```include.hpp``` possui a vari√°vel K que corresponde ao tamanho do heap, tamb√©m pode ser alterada.

## Decis√µes de implementa√ß√£o üìù

```unordered_map:``` Emprega uma tabela de hash para associar chaves a valores. As chaves s√£o identificadores diretos para os dados, e, nesse caso, essas chaves correspondem √†s palavras. Cada valor √© armazenado na forma de uma struct denominada WordInfo, a qual armazena as ocorr√™ncias. √â importante observar que o unordered_map, os elementos ordenados. 

Esse algoritmo trata colis√µes, pela implementa√ß√£o do libstdc++, por exemplo, utiliza uma t√©cnica de encadeamento linear. Enquanto outras implementa√ß√µe podem adotar diferentes estrat√©gias. A biblioteca padr√£o C++ estabelece uma interface que compreende, entre outros recursos, o conceito de bucket_count, que possui uma complexidade de tempo constante. Tal caracter√≠stica indica a aplica√ß√£o do encadeamento de colis√µes, onde itens com hashes semelhantes s√£o agrupados em baldes. Este agrupamento facilita a contagem dos elementos por balde de mesmo valor hash, calculados por fun√ß√µes espec√≠ficas. 

H√° fun√ß√µes de hash do GCC C++ utilizadas, que usam implementa√ß√£o de "MurmurHashUnaligned2".  O nome do algoritmo √© derivado das opera√ß√µes que s√£o realizadas em sequ√™ncia para produzir o hash: multiplica√ß√£o e rota√ß√£o. Murmur faz parte fun√ß√µes de hash de uso geral, adequadas para uso n√£o criptogr√°fico e que garante n√£o ter colis√µes para chaves de 4 bytes.
o algoritmo MurmurHash gera um valor hash √∫nico para um bloco de dados fornecido. A fun√ß√£o itera pelo bloco de dados em segmentos de 32 bits e realiza c√°lculos para cada segmento.

No entanto, cada compilador de C++ deve implementar a biblioteca padr√£o por qualquer meio que optar. Geralmente √© chamada a biblioteca padr√£o inspiradas no STL.
No entanto, √© essencial compreender que diferentes compiladores de C++ podem optar por implementar a biblioteca padr√£o de maneiras diversas, ainda que sejam geralmente influenciados pela abordagem do STL. 

- Melhor caso: $O\;(1)$
- Pior caso:  $O\;(n)$


```Heap:``` Uma heap √© uma √°rvore bin√°ria onde o valor de cada n√≥ √© maior (ou menor) do que os valores de seus n√≥s filhos, dependendo se √© uma max-heap ou min-heap. Nesse caso, o algoritmo implementa uma min-heap, e cada n√≥ tem um valor menor ou igual ao valor de seus filhos, mantendo o menor elemento na primeira posi√ß√£o. O valor a ser armazenado nessa estrutura s√£o as maiores ocorr√™ncias de palavras no texto.

<div style="text-align:center">
    <img src="img/minHeap.png" height="300" width="350">
</div>

O heap √© organizado da seguinte forma:

- Verifica se o n√≥ √† esquerda existe e se o valor de ocorr√™ncias desse n√≥ √© menor que o valor de ocorr√™ncias do n√≥ atual. Se essa condi√ß√£o for verdadeira, atualiza largest para apontar para o n√≥ √† esquerda.
- A fun√ß√£o faz a mesma verifica√ß√£o para o n√≥ da direita. 

Quando se encontra um n√≥ filho com valor menor que o atual, a troca entre os elementos ocorre e fun√ß√£o √© chamada novamente de modo recursivo.
A condi√ß√£o de parada ocorre quando o atual √© maior do que seus n√≥s filhos.

As trocas s√£o feitas usando a fun√ß√£o ```swap```, que aceita dois par√¢metros que ser√£o trocados. Os par√¢metros podem ser de qualquer tipo de dados.
A fun√ß√£o n√£o retorna nada, apenas troca os valores, que nesse caso se refere a troca de uma ocorr√™ncia menor pela outra maior.

Custo: $O\;n\;(log \;  n)$, onde n √© o tamanho da cole√ß√£o de dados e k o n√∫mero de itens mais relevantes.

De modo geral, o custo computacional √©:

- Para percorrer todos os elementos do hash  $O(n)$ <br> 
- Para percorrer todos os elementos do heap  $O\;k\;(log   k)$



 ## Fun√ß√µes  üíª

- ```addStopWord``` : Adiciona as stop words no gloss√°rio destinado para elas.
- ```existentWord```: Verifica as stop words presentes no gloss√°rio e remove elas dele.
- ```manyFiles```: Guarda o nome dos arquivos dos textos de entrada em um vector.
- ```printGlossary``` : Imprimi o gloss√°rio de palavras de ambos os textos juntos.
- ```fileReading``` : Realiza leitura caracter por caracter dos textos de entrada, utilizando um switch case, essa fun√ß√£o processa, identifica as palavras e adiciona cada uma no gloss√°rio.
- ```cases``` : Realiza a contagem de ocorr√™ncia de cada palavra a medida que o texto √© lido.
- ```Accentuation``` : Procedimento que trata palavras acentuadas para aparecerem corretamente.
- ```removeErro``` : Exclui poss√≠veis strings vazias do gloss√°rio.
- ```insertK``` : Insere os primeiros K elementos do hash no heap.
- ```printHeap``` : Imprimi o heap de forma crescente.
- ```finaleHash``` : Realiza inser√ß√£o do restante dos itens do hash, a partir da posi√ß√£o K, insere ou troca as maiores ocorr√™ncias do hash com o menor do heap.
- ```heapify``` : Respons√°vel por garantir que o valor no n√≥ seja maior ou igual aos valores de seus filhos. 
- ```heapSort``` : Ordena o heap de maneira crescente.

 ## Tempo de execu√ß√£o e Custo Computacional üïú

A contagem foi feita pelas ferramentas disponibilizadas pela bibioteca "time.h". <br/>
A m√©dia geral do tempo de execu√ß√£o deste c√≥digo √©: 491,123 ms

Unordered_map: Melhor caso: O(1)
               Pior caso O(n)
               O(1) para a busca, remo√ß√£o e inser√ß√£o de elementos no
melhor caso, e O(n) no pior caso.

Heap:

O(n) ‚Üí para percorrer as palavras do texto
O(k * log k) ‚Üí para inserir os k primeiro itens
O( (n-k) * log k) ‚Üí para tentar inserir o restante dos elementos na heap
O(k) ‚Üí para exibir os K itens

## Resultados ‚úÖ

Ao final da execu√ß√£o √© mostrado o heap com as palavras que cont√©m maiores ocorr√™ncias da cole√ß√£o de dados.
A ordem das ocorr√™ncias seguem a estrutura de um heap.
<div style="text-align:center">
    <img src="img/output.png" height="400" width="400">
</div>

## Conclus√£o üìã

Ao realizar o projeto "Top K itens", foi poss√≠vel explorar t√©cnicas de programa√ß√£o utilizando estruturas como o tabela hash e o m√©todo heap.
Esse algoritmo √© uma combina√ß√£o eficiente do uso de hash para contar a frequ√™ncia dos elementos e heap para manter a lista dos K elementos com maiores valores.
Ao combinar as capacidades de contagem r√°pida de hash e a capacidade de manuten√ß√£o de ordem e sele√ß√£o eficiente de heap, o algoritmo consegue atingir um desempenho not√°vel em termos de complexidade temporal para uma grande entrada de dados, j√° que para a busca dos K maiores itens n√£o √© necess√°rio percorrer todo o heap procurando o menor valor, uma vez que ele estar√° sempre na primeira posi√ß√£o.


## Compila√ß√£o e Execu√ß√£o  üëæ

Esse pequeno exemplo possui um arquivo Makefile que realiza todo o procedimento de compila√ß√£o e execu√ß√£o. <br/>Para tanto, temos as seguintes diretrizes de execu√ß√£o:


| Comando                |  Fun√ß√£o                                                                                           |                     
| -----------------------| ------------------------------------------------------------------------------------------------- |
|  `make clean`          | Apaga a √∫ltima compila√ß√£o realizada contida na pasta build                                        |
|  `make`                | Executa a compila√ß√£o do programa utilizando o gcc, e o resultado vai para a pasta build           |
|  `make run`            | Executa o programa da pasta build ap√≥s a realiza√ß√£o da compila√ß√£o                                 |

## Refer√™ncias 

https://learn.microsoft.com/pt-br/cpp/standard-library/unordered-map-class?view=msvc-170
https://stackoverflow.com/questions/21518704/
https://stackoverflow.com/questions/19411742/
https://www.geeksforgeeks.org/heap-data-structure/
https://www.geeksforgeeks.org/swap-in-cpp/

### Contato

<div>
 <br><p align="justify"> Anna Laura Moura Santana</p>
 <a href="https://t.me/annalaurams">
 <img align="center" src="https://img.shields.io/badge/Telegram-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white"/> 
 </div>
<a style="color:black" href="mailto:nalauramoura@gmail.com?subject=[GitHub]%20Source%20Dynamic%20Lists">
‚úâÔ∏è <i>nalauramoura@gmail.com</i>
</a>