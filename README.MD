# **Top K Elementos**

Atividade para a disciplina de Algoritmos e Estruturas de Dados II. <br/>

## üìïSum√°rio 

- [Objetivo](#objetivo)
- [Estrutura](#estrutura)
- [Diretrizes](#diretrizes)
- [Decis√µes de Implementa√ß√£o](#decis√µes-de-implementa√ß√£o)
- [Fun√ß√µes](#fun√ß√µes)
- [Resultados](#resultados)
- [Tempo De Execu√ß√£o](#tempo-de-execu√ß√£o)
- [Conclus√£o](#conclus√£o)
- [Compila√ß√£o e Execu√ß√£o](#compila√ß√£o-e-execu√ß√£o)
- [Refer√™ncias](#refer√™ncias)

## üéØObjetivo  

O objetivo √© desenvolver um algoritmo utilizando-se tabela hash e o m√©todo heap para resolver um problema cl√°ssico chamado "Top K Itens". 
Neste tipo de problema √© preciso encontrar os K itens mais valiosos de uma cole√ß√£o de dados. Logo, utiliza-se o hash para contar a frequ√™ncia de todos os itens, enquanto o heap se aplica na manuten√ß√£o de uma lista dos K itens de maior valor. 

## üóÇÔ∏èEstrutura  

- ```topk.hpp:``` Apresenta a struct WordInfo.
- ```topk.cpp:``` Cont√©m o desenvolvimento de todas as fun√ß√µes do c√≥digo.    
- ```main.cpp:``` Pertence a parte de leitura dos arquivos, chamada das fun√ß√µes usadas e o tempo de execu√ß√£o do programa.
- ```include.hpp:``` Inclui biliotecas e arquivos a serem utilizados.
- ```text1.txt:``` Texto de entrada. 
- ```text2.txt:``` Texto de entrada. 
- ```stopwords.txt:``` Artigos e conjun√ß√µes como (a, o, as, os, e, ou).

## ‚úîÔ∏èDiretrizes  

As especifica√ß√µes a seguir foram propostas para discuss√£o do problema:

- A partir de um texto de entrada, o algoritmo realiza a leitura dele e cria uma tabela de dispers√£o (hash) intitulada ```glossary```, para contar quantas vezes cada palavra aparece no texto. A chave do hash √© a pr√≥pria palavra e o valor s√£o as ocorr√™ncias, armazenadas em uma struct denominada WordInfo.
- O conte√∫do do arquivo de stop words, pode ser alterado de acordo com a prefer√™ncia do usu√°rio, desde que cada palavra esteja em uma linha do arquivo. 
- As stop words s√£o salvas em outra tabela de dispers√£o. 
- As stop words que forem encontradas no texto, s√£o em seguida exclu√≠das dele. Pois, por serem artigos e conjun√ß√µes facilmente seriam as mais frequentes do heap, no entanto foram desconsideradas.
- O nome do arquivo ```stopwords.txt``` n√£o deve ser alterado.
- Em seguida, a partir de um valor K, √© inserido em um vetor intitulado ```heap``` as primeiras K palavras guardadas no hash e depois s√£o organizadas de forma que a menor ocorr√™ncia das K palavras inseridas, esteja na primeira posi√ß√£o do vetor.
- Ap√≥s isso para cada elemento restante no hash, √© realizado compara√ß√µes com o menor valor contido no heap, esses valores s√£o as ocorr√™ncias:

  1. Se a ocorr√™ncia for maior do que o menor valor da heap, o menor valor √© removido, o novo elemento √© inserido e a estrutura novamente organizada.
  2. Caso contr√°rio, o elemento deve ser ignorado, e √© comparado o pr√≥ximo dado at√© o fim do gloss√°rio.
- No final, a heap conter√° os K elementos com maiores valores (ocorr√™ncias) dentre os textos lidos. 

***Exemplo de inser√ß√£o e compar√ß√£o:***

<div style="display: flex; justify-content: center;">
    <img src="img/exemploHeap.gif" width="300" height="300">
</div>

- Este programa dever√° ler uma cole√ß√£o de arquivos contento textos sem nenhuma formata√ß√£o ("arquivo ASCII") onde cada senten√ßa termina por um sinal de pontua√ß√£o (".", "?", "!"").
- Cada par√°grafo √© separado por, pelo menos, uma linha em branco.
- Considere como palavra uma sequ√™ncia de letras delimitada por espa√ßo em branco, ‚Äùcoluna da esquerda‚Äù, ‚Äùcoluna da direita‚Äù e s√≠mbolos de pontua√ß√£o.

- Todos os arquivos de entrada s√£o lidos caracter por caracter, e utiliza-se um switch case para pontua√ß√£o e caracteres especiais, identificando o in√≠cio e o fim das palavras.
- As palavras que cont√©m h√≠fen, tiveram o h√≠fen removido. Por exemplo "arco-√≠ris" passa a ser "arco√≠ris".

- O programa permite a leitura de v√°rios arquivos de texto ao mesmo tempo, no entanto existem algumas regras:
  1. Para cada novo arquivo que se deseja ler, deve ser colocado dentro da pasta ```data```. 
  2. O nome dos arquivos de texto seguem um padr√£o de "text1.txt" (1¬∞ arquivo), "text2.txt"(2¬∞ arquivo) e assim sucessivamente, logo devem ser renomeados. 
  3. Al√©m disso, a vari√°vel ```FILES``` dentro do ```include.hpp``` guarda a quantidade de arquivos a serem lidos, portanto, modifique para a quantidade desejada.

- Dentro do arquivo ```include.hpp``` possui a vari√°vel K que corresponde ao tamanho do heap, tamb√©m pode ser alterada.

## üìùDecis√µes de implementa√ß√£o  

### unordered_map:  
Estrutura que implementa uma tabela de hash para associar chaves a valores, compondo-se nesse c√≥digo por essa defini√ß√£o  ```unordered_map<string, WordInfo> glossary``` . As chaves s√£o identificadores diretos para os dados. √â importante lembrar tamb√©m que o unordered_map, n√£o mant√©m os elementos ordenados. 

Em uma entrada de dados muito grande, pode ocorrer dados com a mesma chave. Esse algoritmo trata colis√µes, pela implementa√ß√£o do libstdc++, por exemplo, utiliza uma t√©cnica de encadeamento linear, enquanto outras implementa√ß√µes podem adotar diferentes estrat√©gias. A biblioteca padr√£o C++ estabelece uma interface que compreende, entre outros recursos, o conceito de bucket_count, que possui uma complexidade de tempo constante. Tal caracter√≠stica indica a aplica√ß√£o do encadeamento de colis√µes, onde itens com hashes semelhantes s√£o agrupados em baldes. Este agrupamento facilita a contagem dos elementos por balde de mesmo valor hash, calculados por fun√ß√µes espec√≠ficas. 

H√° fun√ß√µes de hash do GCC C++ utilizadas, que usam implementa√ß√£o de "MurmurHashUnaligned2".  O nome do algoritmo √© derivado das opera√ß√µes que s√£o realizadas em sequ√™ncia para produzir o hash: multiplica√ß√£o e rota√ß√£o. Murmur faz parte fun√ß√µes de hash de uso geral, adequadas para uso n√£o criptogr√°fico e que garante n√£o ter colis√µes para chaves de 4 bytes.
o algoritmo MurmurHash gera um valor hash √∫nico para um bloco de dados fornecido. A fun√ß√£o itera pelo bloco de dados em segmentos de 32 bits e realiza c√°lculos para cada segmento.

Custo Computacional unordered_map: <br>
- Melhor caso: $O$  $(1)$
- Pior caso: $O$  $(n)$

### Heap
O heap √© uma estrutura a qual o valor de cada n√≥ √© maior (ou menor) do que os valores de seus n√≥s filhos, dependendo se √© uma max-heap ou min-heap. Nesse caso, o algoritmo implementa uma min-heap, e cada n√≥ tem um valor menor ou igual ao valor de seus filhos, mantendo o menor elemento na primeira posi√ß√£o. Os valores a serem armazenados nessa estrutura s√£o as maiores ocorr√™ncias de palavras no texto.

<div style="text-align:center">
    <img src="img/minHeap.png" height="300" width="350">
</div>

Na implementa√ß√£o do heap, √© utilizado o heapify, um processo usado para transformar um conjunto de elementos em uma estrutura de heap, ou seja, ele rearranja os elementos para que a propriedade do heap seja mantida.

Como se trata de uma minHeap, a estrutura √© organizada da seguinte maneira:

- Verifica se o n√≥ √† esquerda existe e se o valor de ocorr√™ncias desse n√≥ √© menor que o valor de ocorr√™ncias do n√≥ atual. Se essa condi√ß√£o for verdadeira, atualiza maior para apontar para o n√≥ √† esquerda.
- A fun√ß√£o faz a mesma verifica√ß√£o para o n√≥ da direita. 

Quando se encontra um n√≥ filho com valor menor que o atual, a troca entre os elementos ocorre e a fun√ß√£o √© chamada novamente de modo recursivo.

As trocas s√£o feitas usando a fun√ß√£o ```swap```, que aceita dois par√¢metros que ser√£o trocados. Os par√¢metros podem ser de qualquer tipo de dados.
A fun√ß√£o n√£o retorna nada, apenas troca os valores, que nesse caso se refere a troca de uma ocorr√™ncia menor pela outra maior.

Custo Computacional Heap: <br>
$O$  $n(log$ $k)$, onde $n$ √© o tamanho da cole√ß√£o de dados e $k$ o n√∫mero de itens mais relevantes.


 ## üíªFun√ß√µes  

- ```addStopWord``` : Adiciona as stop words no gloss√°rio destinado para elas.
- ```existentWord```: Verifica as stop words presentes no gloss√°rio e remove elas dele.
- ```manyFiles```: Guarda o nome dos arquivos dos textos de entrada em um vector.
- ```printGlossary``` : Imprimi o gloss√°rio de palavras de ambos os textos juntos.
- ```fileReading``` : Realiza leitura caracter por caracter dos textos de entrada, utilizando um switch case, essa fun√ß√£o processa, identifica as palavras e adiciona cada uma no gloss√°rio.
- ```cases``` : Realiza a contagem de ocorr√™ncia de cada palavra a medida que o texto √© lido.
- ```Accentuation``` : Procedimento que trata palavras acentuadas para aparecerem corretamente.
- ```insertK``` : Insere os primeiros K elementos do hash no heap.
- ```printHeap``` : Imprimi o heap.
- ```finaleHash``` : Realiza inser√ß√£o do restante dos itens do hash, a partir da posi√ß√£o K, insere ou troca as maiores ocorr√™ncias do hash com o menor do heap.
- ```heapify``` : Organiza a estrutura heap.

 ## üïúTempo de execu√ß√£o 

A contagem foi feita pelas ferramentas disponibilizadas pela bibioteca "time.h". <br/>
O algoritmo foi executado 10 vezes e obteve-se como m√©dia geral o tempo de: 491,123 ms

## ‚úÖResultados 

Ao final da execu√ß√£o √© mostrado o heap com as palavras que cont√©m maiores ocorr√™ncias da cole√ß√£o de dados.
A ordem das ocorr√™ncias seguem a estrutura de um heap.
<div style="text-align:center">
    <img src="img/exemplo.png" height="400" width="350">
</div>

##  üìãConclus√£o 

Ao realizar o projeto "Top K itens", foi poss√≠vel explorar t√©cnicas de programa√ß√£o utilizando estruturas como a tabela hash e o m√©todo heap.
Esse algoritmo √© uma combina√ß√£o eficiente do uso de hash para contar a frequ√™ncia dos elementos e heap para manter a lista dos K elementos com maiores valores.
Ao combinar as capacidades de contagem r√°pida de hash e a capacidade de ordem eficiente de heap, o algoritmo consegue atingir um desempenho not√°vel em termos de complexidade temporal para uma grande entrada de dados,  j√° que para a busca dos K maiores itens n√£o √© necess√°rio percorrer todo o heap procurando o menor valor, uma vez que ele estar√° sempre na primeira posi√ß√£o.


##  üëæCompila√ß√£o e Execu√ß√£o  

Esse pequeno exemplo possui um arquivo Makefile que realiza todo o procedimento de compila√ß√£o e execu√ß√£o. <br/>Para tanto, temos as seguintes diretrizes de execu√ß√£o:


| Comando                |  Fun√ß√£o                                                                                           |                     
| -----------------------| ------------------------------------------------------------------------------------------------- |
|  `make clean`          | Apaga a √∫ltima compila√ß√£o realizada contida na pasta build                                        |
|  `make`                | Executa a compila√ß√£o do programa utilizando o gcc, e o resultado vai para a pasta build           |
|  `make run`            | Executa o programa da pasta build ap√≥s a realiza√ß√£o da compila√ß√£o                                 |

## Refer√™ncias 

https://learn.microsoft.com/pt-br/cpp/standard-library/unordered-map-class?view=msvc-170 <br>
https://stackoverflow.com/questions/21518704/ <br>
https://stackoverflow.com/questions/19411742/ <br>
https://www.geeksforgeeks.org/heap-data-structure/ <br>
https://www.geeksforgeeks.org/swap-in-cpp/

### Contato 
<div>
 <br><p align="justify"> Anna Laura Moura Santana</p>
 <a href="https://t.me/annalaurams">
 <img align="center" src="https://img.shields.io/badge/Telegram-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white"/> 
 </div>
<a style="color:black" href="mailto:nalauramoura@gmail.com?subject=[GitHub]%20Source%20Dynamic%20Lists">
‚úâÔ∏è <i>nalauramoura@gmail.com</i>
</a>