# **Top K Elementos**

Atividade para a disciplina de Algoritmos e Estruturas de Dados II. <br/>

## Sum√°rio üìï 

- [Objetivos](#Objetivos)
- [Estrutura](#Estrutura)
- [Diretrizes](#Diretrizes)
- [Decis√µes_de_Implementa√ß√£o](#Decis√µes_de_Implementa√ß√£o)
- [Fun√ß√µes](#Fun√ß√µes)
- [Resultados](#Resultados)
- [Tempo de execu√ß√£o e Custo computacional](#Tempo_de_execu√ß√£o_e_Custo_computacional)
- [Conclus√£o](#Conclus√£o)
- [Refer√™ncias](#Refer√™ncias)
- [Compila√ß√£o e execu√ß√£o](#Compila√ß√£o-e-execu√ß√£o)


## Objetivo

O objetivo √© desenvolver um algoritmo utilizando-se tabela hash e o m√©todo heap sort para resolver um problema cl√°ssico chamado "Top K itens". 
Neste tipo de problema √© preciso encontrar os K itens mais valiosos de uma cole√ß√£o de dados. Logo, utiliza-se o hash para contar a frequ√™ncia de todos os itens, enquanto o heap se aplica na manuten√ß√£o de uma lista dos K itens de maior valor. 

## Estrutura

- ```topk.hpp:``` Engloba a struct WordInfo, todas as fun√ß√µes utilizadas e seus par√¢metros.
- ```topk.cpp:``` Cont√©m a cria√ß√£o e o desenvolvimento de todas as fun√ß√µes do c√≥digo.    
- ```main.cpp:``` Pertence a parte de leitura dos arquivos, chamada das fun√ß√µes usadas e o tempo de execu√ß√£o do programa.
- ```include.hpp:``` Inclui biliotecas e arquivos a serem utilizados.
- ```text1.txt:``` Texto de entrada. 
- ```text2.txt:``` Texto de entrada. 
- ```stopwords.txt:``` Artigos e conjun√ß√µes como (a, o, as, os, e, ou).

## Diretrizes

As especifica√ß√µes a seguir foram propostas para discuss√£o e resolu√ß√£o do problema:

- A partir de um texto de entrada, o algoritmo realiza a leitura dele e cria uma tabela de dispers√£o (hash) intitulada ```glossary```, para contar quantas vezes cada palavra aparece no texto. A chave do hash √© a pr√≥pria palavra.
- O arquivo de stopWords, que podem ser alteradas de acordo com a prefer√™ncia do usu√°rio. O conte√∫do deste arquivo √© salvo em outra tabela de dispers√£o e as palavras dele s√£o identificadas no texto, e em seguida exclu√≠das. Pois, por serem artigos e conjun√ß√µes facilmente seriam as mais frequentes do heap, no entanto foram desconsideradas.
- Em seguida, a partir de um valor K, √© inserido em um vetor ```heap``` as primeiras K palavras guardadas no hash e depois s√£o ordenados de forma crescente em rela√ß√£o as ocorr√™ncias destas.
- Ap√≥s isso para cada elemento restante na hash, √© realizado compara√ß√µes com o menor valor contifo no heap, que neste caso est√° na primeira posi√ß√£o do vetor.

  1. Se a ocorr√™ncia for maior do que o menor valor da heap, o menor vaor √© removido, o novo elemento √© inserido e a estrutura novamente ordenada.
  2. Caso contr√°rio, o elemento deve ser ignorado, e √© comparado o pr√≥ximo dado at√© o fim do gloss√°rio.
- No final, a heap conter√° os K elementos com maiores valores (ocorr√™ncias) dentre os textos lidos. Ent√£o, s√£o imprimidos em ordem crescente.

- Exemplifica√ß√£o de como funciona a inser√ß√£o dos K elementos e as demais compara√ß√µes:


<div style="text-align:center">
  <video width="400" height="400" controls>
    <source src="img/exemplo.mp4" type="video/mp4">
  </video>
</div>

-  Este programa dever√° ler uma cole√ß√£o de arquivos contento textos sem nenhuma for-
mata√ß√£o ("arquivo ASCII") onde cada senten√ßa termina por um sinal de pontua√ß√£o (".",
"?", "!"").
- Cada par√°grafo √© separado por, pelo menos, uma linha em branco.
- Considere como palavra uma sequ√™ncia de letras delimitada por espa√ßo em branco, ‚Äùcol-
una da esquerda‚Äù, ‚Äùcoluna da direita‚Äù e s√≠mbolos de pontua√ß√£o.

- O programa permite a leitura de v√°rios arquivos de texto ao mesmo tempo, no entanto existem algumas regras:
  1. Para cada novo arquivo que se deseja ler, deve ser colocado dentro da pasta ```data```. 
  2. O nome dos arquivos de texto seguem um padr√£o de "text1.txt" (1¬∞ arquivo), "text2.txt"(2¬∞ arquivo) e assim sucessivamente, logo devem ser renomeados. 
  3. Al√©m disso, a vari√°vel ```FILES``` dentro do ```include.hpp``` guarda a quantidade de arquivos a serem lidos, portanto, modifique para a quantidade desejada.

- Dentro do arquivo ```include.hpp```possui a vari√°vel K que corresponde ao tamanho do heap, tamb√©m pode ser alterada.

## Decis√µes de implementa√ß√£o

Estruturas escolhidas: Unordered_map, vector e heapSort 

```unordered_map:``` Implementado usando a tabela de hash, o qual tem uma fun√ß√£o de hash para calcular o √≠ndice de armazenamento de cada elemento, permitindo um acesso direto aos dados, sem a necessidade de percorrer todos os eles, ela armazena chave e valor, que nesse caso representa a palavra e sua ocorr√™ncia. O unordered_map n√£o mant√©m os elementos ordenados.
  - Alguns benef√≠cios de usar essas estruturas s√£o: rapidez em acessas elementos e a capacidade de armazenar enormes entradas de dados.

```Heapsort:``` Utiliza uma estrutura de dados chamada "heap" para organizar os elementos, √© como uma √°rvore bin√°ria mantida na forma de um vetor. Neste caso o heap constru√≠do guarda o menor elemento no in√≠cio. Dentro do heapSort √© usado o m√©todo ```heapfy```  que realiza o seguinte procedimento:

  - Come√ßa no √∫ltimo pai da √°rvore, que √© o elemento no meio do array.
Verifica se o pai √© maior ou igual aos seus dois filhos. Se n√£o for, troca o pai com o filho maior.
Continua movendo para cima na √°rvore, verificando e trocando os pais com seus filhos maiores, at√© que chegue ao topo da √°rvore.
No final do algoritmo, o array estar√° convertido em um heap.
  - Em linhas gerais, o m√©todo heapify √© usado no algoritmo de ordena√ß√£o heapsort. O heapsort funciona criando um heap a partir do array original e, em seguida, removendo os elementos do heap em ordem crescente.

  - Alguns benef√≠cios de usar essas estruturas s√£o: Eficientes para grandes entradas de dados.


 ## Fun√ß√µes

- ```addStopWord``` : Adiciona as stop words no gloss√°rio destinado para elas.
- ```existentWord```: Verifica as stop words presentes no gloss√°rio e remove elas dele.
- ```manyFiles```: Guarda o nome dos arquivos dos textos de entrada em um vector.
- ```printGlossary``` : Imprimi o gloss√°rio de palavras de ambos os textos juntos.
- ```fileReading``` : Realiza leitura caracter por caracter dos textos de entrada, utilizando um switch case, essa fun√ß√£o processa, identifica as palavras e adiciona cada uma no gloss√°rio.
- ```cases``` : Realiza a contagem de ocorr√™ncia de cada palavra a medida que o texto √© lido.
- ```Accentuation``` : Procedimento que trata palavras acentuadas para aparecerem corretamente.
- ```removeErro``` : Exclui poss√≠veis strings vazias do gloss√°rio.
- ```insertK``` : Insere os primeiros K elementos do hash no heap.
- ```printHeap``` : Imprimi o heap de forma crescente.
- ```finaleHash``` : Realiza inser√ß√£o do restante dos itens do hash, a partir da posi√ß√£o K, insere ou troca as maiores ocorr√™ncias do hash com o menor do heap.
- ```heapify``` : Respons√°vel por garantir que o valor no n√≥ seja maior ou igual aos valores de seus filhos. 
- ```heapSort``` : Ordena o heap de maneira crescente.

 ## Tempo de execu√ß√£o e Custo Computacional

A contagem foi feita pelas ferramentas disponibilizadas pela bibioteca "time.h". <br/>
A m√©dia geral do tempo de execu√ß√£o deste c√≥digo √©: 

Unordered_map:

Heapsort: O(nlogk), onde n √© o tamanho da cole√ß√£o de dados e k o n√∫mero de itens mais relevantes.

## Resultados

Ao final da execu√ß√£o √© mostrado o heap com as palavras que cont√©m maiores ocorr√™ncias da cole√ß√£o de dados, em ordem crescente.


### **Conclus√£o**

Ao realizar o projeto "Top K itens", foi poss√≠vel explorar t√©cnicas de programa√ß√£o utilizando estruturas como o tabela hash e o m√©todo heap, para grande entradas de dados.
Esse algoritmo √© uma combina√ß√£o eficiente do uso de hash para contar a frequ√™ncia dos elementos e heap para manter a lista dos K elementos com maiores valores.
Ao combinar as capacidades de contagem r√°pida de hash e a capacidade de manuten√ß√£o de ordem e sele√ß√£o eficiente de heap, o algoritmo consegue atingir um desempenho not√°vel em termos de complexidade temporal para uma grande entrada de dados.

<img src="imagens/terminal.png" height="550" width="350">


### Compila√ß√£o e Execu√ß√£o

Esse pequeno exemplo possui um arquivo Makefile que realiza todo o procedimento de compila√ß√£o e execu√ß√£o. <br/>Para tanto, temos as seguintes diretrizes de execu√ß√£o:


| Comando                |  Fun√ß√£o                                                                                           |                     
| -----------------------| ------------------------------------------------------------------------------------------------- |
|  `make clean`          | Apaga a √∫ltima compila√ß√£o realizada contida na pasta build                                        |
|  `make`                | Executa a compila√ß√£o do programa utilizando o gcc, e o resultado vai para a pasta build           |
|  `make run`            | Executa o programa da pasta build ap√≥s a realiza√ß√£o da compila√ß√£o                                 |



### Contato

<div>
 <br><p align="justify"> Anna Laura Moura Santana</p>
 <a href="https://t.me/annalaurams">
 <img align="center" src="https://img.shields.io/badge/Telegram-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white"/> 
 </div>
<a style="color:black" href="mailto:nalauramoura@gmail.com?subject=[GitHub]%20Source%20Dynamic%20Lists">
‚úâÔ∏è <i>nalauramoura@gmail.com</i>
</a>